"""
DOCUMENTATION

Program to generate 1 row of P-Matrix.
	
	Description:
		-> The program generates one row of a P-Matrix - the output is the probability
			matrix of dimensions 1xn where n is the number of states generated by the given
			matrix. Thus, each element in this row matrix represents the probability of reaching
			the corresponding state from the given state (the given matrix).
		-> The output is a list of lists. 
		-> Each list within the larger list contains the probability elements for the corresponding state.
		-> For example, let the output be result = [[12,12],[18]]. This means that the probability of
			reaching State 1 from State 1 is [12,12], while the probability of reaching State 2 from State 1
			is [18].
		-> The probabilty elements are in format [a,b,...n] where the probability is computed in the format -
			p = 1/a + 1/b... + 1/n. Thus in the aforementioned example, p(1,1)= 1/12 + 1/12 = 1/6 and
			p(1,2)= 1/18.
		-> The probability is represented in this format to minimize mathematical or rounding errors while
			converting to decimals. (The program is part of a larger project wherein the output is then fed
			into Pari GP to find the most accurate fractional results.)
			
	Example:
		-> Input for main function: mat = [[2,0],[0,0]], num_range = [0,2]
		-> Output: [[12, 12], [12, 12], [18], [12, 12], [12, 12], [18], [18], [18], [18], [18]]
		(translates to [ 1/6 , 1/6 , 1/18 , 1/6 , 1/6 , 1/18 , 1/18 , 1/18 , 1/18 , 1/18 ])

Sections of the program -
	
	1. Tree Class -
		- Has the following attributes -
			-> state - vector representation of matrix
			-> state_number
			-> probability
			-> children - the substitution/permutation of the vector
			-> super_states 
		- Has the following functions -
			-> add_state_number()
			-> add_probability()
			-> add_child()
			-> get_children()
			-> get_state_number()
			-> get_state()
			-> get_probability
			-> get_node()
			-> all_same_nodes()
			-> return_state_given_num()
			-> get_num_states()
			-> get_all_states()
			-> generate_super_states()
			-> get_super_states()
		
	2. Main Program Functions -
		-> main()
		-> assemble_probabilities()
		-> create_tree()
		-> add_level_two()
		-> add_state()
		-> add_state_level_one()
		-> add_state_level_two()
		-> probability()
		-> all_states_list()
	
	3. Permutation Functions - 
		-> permutation()
		-> permutations_helper()

	4. Substitution Functions - 
		-> matrix_substitutions()
		-> matrix_substitution_helper()
		-> matrix_combinations()
		-> block_substitution()

	5. Miscellaneous Helper Functions - 
		-> matrix_to_vector()
		-> eliminate_duplicates()
		-> make_matrix()

Written by - Rhea Dutta. Date - 06/15/2018.
"""

#-------------------------- MAIN PROGRAM FUNCTIONS -------------------------------------#

def main(mat, num_range, sub):
	"""
	RETURNS: The probability matrix of dimenions 1xn where n is the number of states
			generated by the given matrix mat.
			
	PARAMETERS: mat [multi-dimensional array]: The matrix whose p-matrix must be found.
				num_range [list]: The range of numbers that can be substituted in the
								matrix in the format [min,max].
								Eg: [0,255] for RGB.
				sub [int]: The size of the block used in the substituition step. For example,
							if sub = 2, pairwise substituion. If sub = 4, substitution for
							every four pixels.
	
	"""
	result = assemble_probabilities(mat, num_range, sub)
	return result
	
#########################################################################################

def assemble_probabilities(mat, num_range, sub):
	"""
	RETURNS: The probability row matrix for matrix mat.
	
	PARAMETERS: mat [multi-dimensional array]: The matrix whose p-matrix must be found.
				num_range [list]: The range of numbers that can be substituted in the
								matrix in the format [min,max].
								Eg: [0,255] for RGB.
				sub [int]: The size of the block used in the substituition step. For example,
							if sub = 2, pairwise substituion. If sub = 4, substitution for
							every four pixels.
	
	"""
	
	#Creating the tree.
	tree = create_tree(mat, num_range, sub)

	if len(tree.get_all_states()) == 1:
		return [[0]]
	
	#Calculating the number of states.
	num_states = tree.get_num_states()

	prob_list = [[0]]*num_states #Contains all the probabilities for the row matrix. 
	state_list = [] #Contains all the state numbers for the tree.
	
	for k in range(1, num_states+1):
		for i in tree.get_children():
			for j in i.get_children():
				if j.get_state_number()==k:
					prob_list[k-1] = j.get_probability()
					state_list.append(k)
					break
			if j.get_state_number()==k:
				break
		if len(state_list)==num_states:
			return prob_list

	return prob_list

#########################################################################################

def create_tree(mat, num_range, sub):
	"""
	RETURNS: The tree object that contains all substitutions and permutations of the
			given matrix. In the format -
											-> root node - given matrix mat.
											-> level one nodes - substitutions of matrix mat.
											-> level two nodes - permutations of the substitutions.
											
	PARAMETERS: mat [multi-dimensional array]: The matrix whose p-matrix must be found.
				num_range [list]: The range of numbers that can be substituted in the
								matrix in the format [min,max].
								Eg: [0,255] for RGB.
				sub [int]: The size of the block used in the substituition step. For example,
							if sub = 2, pairwise substituion. If sub = 4, substitution for
							every four pixels.
	
	"""
	
	root_matrix = matrix_to_vector(mat) #Vector form of root matrix mat.
	#root_matrix is the root node of the tree.
	matrix_subs = matrix_substitutions(mat, num_range, sub) #List of subsitution vectors.
	#matrix_subs is the list of level one nodes in the tree.
	
	tree = Tree(root_matrix,1) #root_matrix has state_number 1.
	
	#Adding Level 1 (substitution) nodes to the tree.
	for subst in matrix_subs:
		node = Tree(subst)
		tree.add_child(node)
	
	#Adding state_numbers for level 1. 
	add_state(tree, tree.get_children(), False)
	
	#Adding Level 2 (permutation) nodes to the tree.
	child_list = tree.get_children()
	add_level_two(child_list) #optimization 
	l = all_states_list(tree)
	
	state_added = []
	#Adding state_numbers to level 2 nodes 
	for child in child_list: #Level 1 nodes
		add_state(child, child.get_children(), True, tree, l, state_added)
		
	#Generating and storing super states to generate condensed matrix later on.
	tree.generate_super_states()
	
	return tree
			
#########################################################################################

def add_level_two(child_list):
	"""
	Adds level two nodes to the tree by adding children to the given list of Tree objects.
	Level two nodes are basically permutations of the respective parent nodes. This is
	essentially optimizing computations by detecting repeated states at the first level.
	It computes the permutations of the repeated state only once and then copies the list
	of children to all other occurences of the state.
	
	PARAMETERS: child_list [list of Tree objects]: Contains level one nodes of the tree.
	
	"""
	
	for child in child_list:
		pos = child_list.index(child)
		current_state = child.get_state_number() 
		prev_states = []
		for prev_child in child_list[:pos]:
			prev_states.append(prev_child.get_state_number())
			
		if current_state in prev_states: #Repeated state at the first level.
			repeat_index = prev_states.index(current_state)
			child.children = tree.children[repeat_index].children
			
		else: #Not repeated. 
			permutations = eliminate_duplicates(permutation(child.get_state()))
			for perm in permutations:
				node = Tree(perm)
				child.add_child(node)
	
#########################################################################################
	
def add_state(given_tree, children, level2=True, root_tree = None, l = [], state_added =[]):
	"""
	Adds state_numbers to the nodes in the different levels of the tree. Calls functions
	add_state_level_one() and add_state_level_two() to add state_numbers to the nodes
	in the respective levels. It also updates probability by calling probability() function.
	
	PARAMETERS: given_tree [Tree]: The Tree object to whose children nodes state
									numbers must be added.
				children [list of Tree objects]: Contains the Tree objects to whom
									state numbers must be added.
				level2 [Bool]: Indicates whether level two nodes are being intialized or not.
				root_tree [Tree]: The parent of given_tree - the root node of tree.
				l [list]: Initialized in generate_pmatrix(). Contains all state numbers in the
							root_tree. It is the result of all_states_list().
							Used to update the largest state_number so as to accurately count
							and label the states that are being added.
				state_added [list]: Initialized in generate_pmatrix(). Contains all states
							that have already been given state_numbers. Is updated every time
							state_number is added to a node in the tree.
	
	"""
	
	#Adding states for level 1 nodes.
	if level2 is False:  
		add_state_level_one(given_tree,children) #adds states_numbers 
		probability(given_tree,level2)
				
	#Adding states for level 2 nodes
	else: 
		add_state_level_two(given_tree, children, root_tree, l, state_added)
	
#########################################################################################

def add_state_level_one(given_tree, children):
	"""
	Adds state_numbers to the level one nodes of tree.
	
	PARAMETERS: given_tree [Tree]: The Tree object to whose children nodes state
									numbers must be added.
				children [list of Tree objects]: Contains the Tree objects to whom
													state numbers must be added.

	"""
	
	parent_node = given_tree 
	nodes = []
	for i in range(len(children)):
		nodes.append(children[i].get_state())
	
	for node in nodes:
		pos = nodes.index(node)
		before = nodes[:pos]
		#after = nodes[pos+1:]
		if node in before: #repeated state
			repeated_pos = before.index(node)
			children[pos].add_state_number(children[repeated_pos].get_state_number())
		else: #new state
			if nodes.index(node)==0: #first child in list
				if node == parent_node.get_state(): #same state as parent
					latest_state = parent_node.get_state_number()
				else:
					latest_state = 2 #if not same state as parent(1), then it is (2)
			
			else: #not first child in list
					
				prev_states = []	
				for i in range(len(nodes[:pos])):
					prev_states.append(children[i].get_state_number())
					
				if node == parent_node.get_state():
					latest_state = parent_node.get_state_number()
				else:
					latest_count = max(prev_states)
					latest_state = latest_count + 1 
			children[pos].add_state_number(latest_state)

#########################################################################################

def add_state_level_two(given_tree, children, root_tree, l, state_added):
	"""
	Adds state_numbers to the level two nodes of tree. 
	
	PARAMETERS: given_tree [Tree]: The Tree object to whose children nodes state
									numbers must be added.
				children [list of Tree objects]: Contains the Tree objects to whom
									state numbers must be added.
				root_tree [Tree]: The parent of given_tree - the root node of tree.
				l [list]: Initialized in generate_pmatrix(). Contains all state numbers in the
							root_tree. It is the result of all_states_list().
							Used to update the largest state_number so as to accurately count
							and label the states that are being added.
				state_added [list]: Initialized in generate_pmatrix(). Contains all states
							that have already been given state_numbers. Is updated every time
							state_number is added to a node in the tree.
	"""
	grandparent_node = root_tree
	parent_node = given_tree 
	nodes = []
	for i in range(len(children)):
		nodes.append(children[i].get_state())
	
	all_children = []
	for parent in grandparent_node.get_children():
		for child in parent.get_children():
			all_children.append(child.get_state())
	
	for node in nodes:
		pos = nodes.index(node)
		before = nodes[:pos]
		#after = nodes[pos+1:]
		
		if node not in state_added:
			if node in before: #repeated node under same parent
				repeated_pos = before.index(node)
				children[pos].add_state_number(children[repeated_pos].get_state_number())
				state_added.append(node)
				probability(given_tree, True, 0, children[pos])	
			else: #new node 
				if node == parent_node.get_state(): #same state as parent
					latest_state = parent_node.get_state_number()
					state_added.append(node)
				elif node == grandparent_node.get_state(): #same state as root node
					latest_state = grandparent_node.get_state_number()
					state_added.append(node)
				elif node in [sibling.get_state() for sibling in grandparent_node.get_children()]: #same state as parent's sibling nodes 
					sibling_nodes = []
					for sibling in grandparent_node.get_children():
						sibling_nodes.append(sibling.get_state())
					i = sibling_nodes.index(node)
					latest_state = grandparent_node.get_children()[i].get_state_number()
					state_added.append(node)
				else:
					latest_state = max(l)+1
					state_added.append(node)
					l.append(latest_state)
				children[pos].add_state_number(latest_state)
				probability(given_tree, True, 0, children[pos])
		else: #state repeated at level 2
			children[pos].add_state_number(grandparent_node.get_node(node))
			m = len(parent_node.get_children())
			n = parent_node.get_probability()[0]
			probability(given_tree, True, m*n , children[pos], grandparent_node, grandparent_node.get_node(node))

#########################################################################################

def probability(given_tree, level2, p = 0, child = None, root_tree = None, st_num = None):
	"""
	Updates probability attribute of the children of a given tree.
	
	PARAMETERS: given_tree [Tree]: The Tree object whose children nodes's probabilities
									must be calculated.
				level2 [Bool]: Indicates whether level two nodes are being intialized or not.
				p [int]: Probability factor that must be appended to level 2 node if it occurs
						multiple times in the tree.
				child [Tree]: Level 2 node that must be intialized 
				root_tree [Tree]: Root node of the entire tree.
				st_num [int]: state_number of the node that appears multiple times in the second
							level of the root_tree. 
	
	"""
	#Setting probability for level 1 nodes. 
	if level2 is False: 
		n = len(given_tree.get_children())
		for child in given_tree.get_children():
			child.add_probability(n)
	
	#Setting probability for level 2 nodes. 
	else:
		if p==0: #Level 2 node is not repeated - initialized for the first time.
			m = len(given_tree.get_children())
			n = given_tree.get_probability()[0]
			child.add_probability(m*n)
		else: #Level 2 node has been repeated - must append p to probability.
			for i in root_tree.all_same_nodes(st_num):
				i.add_probability(p)
				
#########################################################################################

def all_states_list(root_tree):
	"""
	RETURNS: A list of all state_numbers in the entire tree.
	
	PARAMETERS: root_tree[Tree]: The root node of the Tree tree. 
	"""
	state_numbers = []
	
	#Adding Level1 nodes' state_number to list.
	for level1_node in root_tree.get_children():
		state_numbers.append(level1_node.get_state_number())
		
	level1_nodes = []
	for parent in root_tree.get_children():
		level1_nodes.append(parent)
	
	#Adding Level2 nodes' state_number to list	
	for parent in level1_nodes:
		for child in parent.get_children():
			state_numbers.append(child.get_state_number())
	
	return state_numbers 

#------------------------------------- TREE CLASS --------------------------------------#	

class Tree(object):
	"""
	- Has the following attributes -
			-> state - vector representation of matrix.
			-> state_number
			-> probability 
			-> children - the substitution/permutation of the vector.
			-> super_states
	- Has the following functions -
			-> add_state_number()
			-> add_probability()
			-> add_child()
			-> get_children()
			-> get_state_number()
			-> get_state()
			-> get_probability() 
			-> get_node()
			-> all_same_nodes()
			-> return_state_given_num()
			-> get_num_states()
			-> get_all_states()
			-> generate_super_states()
			-> get_super_states()
	"""
	
	def __init__(self, state, state_number=0, probability=None, children=None, super_states=None):
		"""
		state [list]: The state of the matrix. Eg: [0,2,0,0]
		state_number [int]: The state number of the state. Eg: [0,2,0,0] has state_number 1.
		probability [list]: Probability of reaching the current node from the root node.
		children [Tree]: The nodes that can be reached from the current Tree.
						It is a list of Tree objects. 
		
		"""
		self.state = state
		
		self.add_state_number(state_number)
		
		self.probability = []
		
		self.children = []
		
	
	def __repr__(self):
		"""
		Returns the string representation of the tree in format <State #: x, State: y>.
		"""
		return str("State #: "+ str(self.get_state_number()) + "State: " + str(self.get_state()))
	
	def add_state_number(self, state_number):
		"""
		Adds the state_number.
		"""
		self.state_number = state_number
		
	def add_probability(self, p):
		"""
		Adds the weight of preceeding branch (p) to the probability attribute.
		"""
		self.probability.append(p)
	
	def add_child(self, node):
		"""
		Adds a child to the Tree.
		"""
		assert isinstance(node, Tree)
		self.children.append(node)
		
	def get_children(self):
		"""
		Returns the parameter "children" which is a list of Tree objects.
		"""
		return self.children
	
	def get_state_number(self):
		"""
		Returns the state_number.
		"""
		return self.state_number
	
	def get_state(self):
		"""
		Returns the state.
		"""
		return self.state
	
	def get_probability(self):
		"""
		Returns the probability attribute of the tree.
		"""
		return self.probability
	
	def get_node(self,state):
		"""
		RETURNS: The state_number of any node with the given state in the tree. 
		PARAMETERS: state [list]: State whose corresponding state_number
					must be returned. 
		"""
		for i in self.get_children():
			for j in i.get_children():
				if j.get_state()==state:
					return j.get_state_number()
				
	def all_same_nodes(self, st_num):
		"""
		RETURNS: A list of all tree objects whose state numbers are the same.
		"""
		
		result = []
		for i in self.get_children():
			for j in i.get_children():
				if j.get_state_number()==st_num:
					result.append(j)
		return result
	
	def return_state_given_num(self, st_num):
		"""
		RETURNS: The state of a tree given its state number. 
		"""
		for i in self.get_children():
			for j in i.get_children():
				if j.get_state_number()==st_num:
					return j.get_state()
				
	def get_num_states(self):
		"""
		RETURNS: The total number of states in the tree. 
		"""
		num_states = 0
		for i in self.get_children():
			for j in i.get_children():
				if j.get_state_number()>num_states:
					num_states = j.get_state_number()
		return num_states
	
	def get_all_states(self):
		"""
		RETURNS: A list of all states in the tree. 
		"""
		num_states = self.get_num_states()
		
		l = []
		
		for k in range(1, num_states+1):
			for i in self.get_children():
				for j in i.get_children():
					if j.get_state_number()==k:
						l.append(j.get_state())
						break
				if j.get_state_number()==k:
					break

		if self.get_state() not in l:
			l.insert(0,self.get_state())

		return l
	
	def generate_super_states(self):
		"""
		Updates super_states attribute.
		"""

		l2_state_numbers = [] #[[numbers],[numbers],[numbers]]
		for parent in self.get_children():
			l = []
			for child in parent.get_children():
				l.append(child.get_state_number())
			l2_state_numbers.append(l)
		
		x = []
		y = []
		for l in l2_state_numbers:
			new_l = []
			for st_num in l:
				if st_num not in y:
					new_l.append(self.return_state_given_num(st_num))
					y.append(st_num)
			if len(new_l)>0:
				x.append(new_l)

		#If root node not in super states, add it.
		present = False
		for l in x:
			if self.get_state() in l:
				present = True
		
		if present is False:
			x.append([self.get_state()])

		self.super_states = x

	def get_super_states(self):
		"""
		Returns super_states.
		"""
		return self.super_states
		
#########################################################################################

#-------------------------- PERMUTATION FUNCTIONS --------------------------------------#

#########################################################################################

def permutation(mat_list):
	"""
	Returns the list of permuations of given list by calling permutation_helper.
	
	RETURNS: A list of all the permutations of the given list.
			(returns a list of lists)
			
	PARAMETERS: mat_list(list): The list whose permutations need to be found.
	
	EXAMPLE: Input = [0,2] , Output = [[0, 2], [2, 0]]
	"""

	if len(mat_list) == 0: #Zero elements, zero permutations.
		return []
	if len(mat_list) == 1: #One element, one permutation. 
		return [mat_list]
	
	#Permutations of mat_list are calculated.        
	return permutation_helper(mat_list)

#########################################################################################

def permutation_helper(lst):
	"""Recursive function that returns permutations of a given list.
	
	RETURNS: A list of all the permutations of the given list.
			(returns a list of lists - 2D list)
			
	PARAMETERS: lst(list): The list whose permutations need to be found.
	
	CITATION: https://www.geeksforgeeks.org/generate-all-the-permutation-of-a-list-in-python/
	
	EXAMPLE: Input = [0,2] , Output = [[0, 2], [2, 0]]
	"""
	
	if len(lst) == 0: #Zero elements, zero permutations.
		return []
	if len(lst) == 1: #One element, one permutation. 
		return [lst]
	
	# Find the permutations for lst if there are more than 1 characters
	l = [] # empty list that will store current permutation
	
	# Iterate the input(lst) and calculate the permutation
	for i in range(len(lst)):
		m = lst[i]
		# Extract lst[i] or m from the list.  remLst is remaining list
		remLst = lst[:i] + lst[i+1:]
		# Generating all permutations where m is first element
		for p in permutation_helper(remLst):
			l.append([m] + p)
	
	return l

#########################################################################################

#------------------------- SUBSTITUTION FUNCTIONS --------------------------------------#

#########################################################################################

def matrix_substitutions(mat, num_range, sub):
	"""
	RETURNS: A list of all possible matrix substitutions in the form of
			vectors. (list of lists). In the format - [[matrix sub 1], [matrix sub 2]]
			where every matrix sub is - row1 ele1, row1 ele2, row2 ele1 row2 ele2
			
	PARAMETERS: mat(Multi-dimensional list): The matrix whose substitutions
												need to be found.
				num_range(list): The range of numbers that can be substituted in the
								matrix in the format [min,max].
								Eg: [0,255] for RGB.
				sub [int]: The size of the block used in the substituition step. For example,
							if sub = 2, pairwise substituion. If sub = 4, substitution for
							every four pixels.
								
	EXAMPLE: Input: mat = [[0,2],[0,0]], num_range = [0,2] ;
			Output: [[0,2,0,0],[2,0,0,0],[1,1,0,0]]
	"""
	row_subs = matrix_combinations(mat, num_range, sub)
	mat_subs = matrix_substitution_helper(row_subs)
	
	matrix_subs = []
	for subst in mat_subs:
		matrix_subs.append(list(subst))
	
	final_matrix_subs = []
	for subst in matrix_subs:
		final_matrix_subs.append(matrix_to_vector(subst))
		
	return final_matrix_subs
	
#########################################################################################

def matrix_substitution_helper(row_subs):
	"""
	Function that finds all combinations of the matrix given the different
	substitutions of each row.
	
	RETURNS: A list of all possible combinations of matrices. (3D list)
	
	PARAMETERS: row_subs[list]: The list of substitutions possible for a pair
				of elements. 
	
	EXAMPLE: Input: row_subs= [[[0, 2], [1, 1], [2, 0]], [[0, 0]]]
			Output: [[[0,2],[0,0]],[[1,1],[0,0]],[[1,1],[0,0]]]
	
	
	"""	
	import itertools
	return list(itertools.product(*row_subs))

#########################################################################################

def matrix_combinations(mat,num_range, sub):
	"""
	RETURNS: A list of all possible substitutions for every pair of elements
			in the matrix.
			(list of lists of lists).
			
	PARAMETERS: mat(Multi-dimensional array): The matrix whose substitutions
												need to be found.
				num_range(list): The range of numbers that can be substituted in the
								matrix in the format [min,max].
								Eg: [0,255] for RGB.
				sub [int]: The size of the block used in the substituition step. For example,
							if sub = 2, pairwise substituion. If sub = 4, substitution for
							every four pixels.
								
	EXAMPLE: Input: mat = [[0,2],[0,0]], num_range = [0,2] ; Output = [[[0, 2], [1, 1], [2, 0]], [[0, 0]]]
	"""
	
	vec = matrix_to_vector(mat) #Vector form of matrix mat.
	n = len(vec) #Total number of elements in vec.
	
	matrix_subs = [] #Contains the substitution vectors for every pair of elements.
	for i in range(0,n,sub):
		block = vec[i:i+sub]  #[vec[i],vec[i+1]]
		matrix_subs.append(block_substitution(block, num_range, sub))
		
	return matrix_subs
	
#########################################################################################

def block_substitution(block, num_range, sub):
	"""
	RETURNS: A list of all possible substitutions for the given
			block of numbers. (list of lists)
			
	PARAMETERS: block(list): Given block of numbers to substitute.
				num_range(list): The range of numbers that can be
								substituted in the matrix in the format [min,max].
								Eg: [0,255] for RGB.
				sub [int]: The size of the block used in the substituition step. For example,
							if sub = 2, blockwise substituion. If sub = 4, substitution for
							every four pixels.
								
	EXAMPLE: Input: block =[0,2], num_range = [0,2] , sub = 2; Output: [[0,2],[1,1],[2,0]]
			Input: [0,0], num_range = [0,10], sub = 2 ; Output: [[0,0]]
	"""
	
	import itertools
	n = num_range[1]+1 #(max+1)
	target = sum(block)
	l = [range(n)]*sub
	result = [seq for seq in list(itertools.product(*l)) if sum(seq)==target]

	return result 

#########################################################################################

#------------------------- MISCELLANEOUS FUNCTIONS -------------------------------------#

#########################################################################################

def matrix_to_vector(mat):
	"""
	RETURNS: A list of elements in the matrix.
			(Essentially a vector form of the matrix.)
			Reduces a 2D list to a 1D list.
			
	PARAMETERS: mat(multi-dimensional array): The matrix that must be converted
											to a vector.
											
	EXAMPLE: Input: [[1,2],[3,4]], Output: [1,2,3,4]
			Input: [[[1,2],[3,4]],[[5,6],[7,8]]], Output: [[1,2],[3,4],[5,6],[7,8]]
	"""
	
	vector = []
	for i in range(len(mat)):
		for j in range(len(mat[i])):
			vector.append(mat[i][j])
			
	return vector

#########################################################################################

def eliminate_duplicates(matrix_subs):
	"""Eliminates duplicate matrices from the list matrix_subs.
	
	RETURNS: A list of matrix substitutions without any duplicate matrices.
			(returns a list of lists - 2D list)
			
	PARAMETERS: matrix_subs(list of lists - 2D list):
				matrix_subs is in format: [matrix 1, matrix 2]
				where matrix n = [row1 ele1, row1 ele2, row2 ele1, row2 ele2]
				
	EXAMPLE: Input: [[1,2],[4,5],[1,2],[3,4],[4,5]].
			Output: [[1,2],[3,4],[4,5]]
	"""
	
	#eliminating duplicates        
	final_subs = []
	for pos in range(len(matrix_subs)):
		remaining = matrix_subs[pos+1:]
		if (matrix_subs[pos] in remaining)==False:
			final_subs.append(matrix_subs[pos])
	
	#final_subs does not have any duplicate matrices.
	return final_subs

#########################################################################################

def make_matrix(vector):
	"""
	Makes matrix out of the given vector.
	
	PARAMETERS: vector [list]: The 1D list that must be converted to a 2D list.  
	
	"""
	matrix = []
	for j in range(0, len(vector),2):
		matrix.append([vector[j],vector[j+1]])
			
	return matrix

#########################################################################################

"""m = [[2,0],[0,0]]
n = [0,2]
s = 2

b = [2,0]

block_substitution(b,n,s)"""